notes:

How I originally fetched recipes using get static props.
This is server side rendering.
I moved away from this on Monday 2/15 or Tuesday

// MUST USE ABSOLUTE PATH FOR THIS TO WORK
// export async function getStaticProps(context) {
//   const res = await fetch('http://localhost:5000/api/recipes')
//   const recipeData24 = await res.json()

//   if (!recipeData24) {
//     return {
//       notFound: true,
//     }
//   }

//   return {
//     props: {recipeData24,}, // will be passed to the page component as props
//   }
// }


Tried this but couldn't get it to work, gave up on it earlier this wee
Thursday 2/18
  // Split title on the word if awkward 2 liner
  let recipeTitle = props.title;
  if (recipeTitle.length > 31 && recipeTitle.length < 43) {
    let titleSplit = recipeTitle.split(" ");
    let count = 0;
    let spliceIndex = 0;
    for (let i=0; i< titleSplit.length; i++) {
      count += titleSplit[i].length;
      if (count>20) {
        spliceIndex = i;
        break;
      }
    }
    titleSplit.splice(spliceIndex, 0, '{"\n"}');
    recipeTitle = titleSplit.join(" ");
  }



// MUST USE ABSOLUTE PATH FOR THIS TO WORK
// fetch returns a promise to get the data
// data is an http Response object promise <> Response
// await is keyword to allow you to await a promise
// This is the static way to fetch data, Today is Day 9 on this project
// Need to evolve.
// export async function getStaticProps(context) {
//   const res = await fetch('http://localhost:5000/api/recipes')
//   const recipeData24 = await res.json()

//   if (!recipeData24) {
//     return {
//       notFound: true,
//     }
//   }

//   return {
//     props: {recipeData24} // will be passed to the page component as props
//   }
// }


// Resource: Codecademy.com React
// const options = ["Bell Pepper", "Sausage", "Pepperoni", "Pineapple"];

// export default function PersonalPizza() {
//   const [selected, setSelected] = useState([]);
 
//   const toggleTopping = ({target}) => {
//     const clickedTopping = target.value;
//     setSelected((prev) => {
//      // check if clicked topping is already selected
//       if (prev.includes(clickedTopping)) {
//         // filter the clicked topping out of state
//         return prev.filter(t => t !== clickedTopping);
//       } else {
//         // add the clicked topping to our state
//         return [clickedTopping, ...prev];
//       }
//     });
//   };
 
//   return (
//     <div>
//       {options.map(option => (
//         <button value={option} onClick={toggleTopping} key={option}>
//           {selected.includes(option) ? "Remove " : "Add "}
//           {option}
//         </button>
//       ))}
//       <p>Order a {selected.join(", ")} pizza</p>
//     </div>
//   );
// }


//fetch('/recipes_data') -> Promise<response>
//  This is going to fetch the data and it's going to wait until it's fetched.




export default function Home(props) {
  // best place to fetch data because it's called right away

  const fetcher3 = url => fetch(url).then(r => r.json())

  let user_id = 1;
  // useSWR takes 2 parameters: the URL, and how to fetch it (.then promise)
  // beneath the hood useSWR has 1 object with 2 keys returned, data and error
  // we call this destructuring :)
  const { data, error } = useSWR(`/api/users/${user_id}/recipes`, fetcher3)

  if (error) return <div>failed to load</div>
  if (!data) return <div>loading...</div>

  // DON'T EVEN NEED THIS
  // // return object with key props and value recipe data so you can just use props. from now on
  // return {
  //   props: {recipeData24}
  // };
  // // I self called this so I won't have to call it right afterward. :)
